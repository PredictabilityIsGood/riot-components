<widget-grid>
    <table class="p-0 m-0 table table-hover table-sm" onkeyup="{controlModifier}" onkeydown="{controlModifier}">
        <thead class="widget-grid-header thead-{state.theme.bg}">
            <tr>
                <th class="cell-counter border-{state.theme.border} text-muted">#</th>
                <th onclick="{()=>sort(key)}" class="c-pointer button-{state.theme.bg} text-{state.theme.text} row-header" if="{key in state.options && state.options[key].visible==true}" each="{key in state.datakeys}" scope="col">{state.options[key].alias || key} 
                    <span class="float-right w-0">
                        <span if="{state.sort[key] && state.sort[key].type=='DESC'}" id="{key+'-DESC'}" class="order-desc">
                                &#10142;
                        </span>
                        <span if="{state.sort[key] && state.sort[key].type=='ASC'}" id="{key+'-ASC'}" class="order-asc">
                                &#10142;
                        </span>
                    </span>
                </th>
                <th class="cell-counter border-{state.theme.border} text-muted">
                    <input onclick="{toggleAll}" type="checkbox" checked="{state.all}"/>
                </th>
            </tr>
        </thead>
        <tbody>
            <tr if="{isVisible(index)}" each="{(row,index) in state.data}">
                <td class="cell-counter border-{state.theme.border} bg-{state.theme.bg} text-{state.theme.text}">
                    <span class="row-menu-wrapper">
                        {index+1}
                    </span>
                </td>
                <td if="{key in state.options && state.options[key].visible==true}" 
                    class="c-pointer {state.theme.matchContents ? 'border-'+state.theme.border : ''} {state.theme.matchContents ? 'bg-'+state.theme.bg : ''} {state.theme.matchContents ? 'text-'+state.theme.text : ''}" 
                    each="{key in state.datakeys}" onclick="{ ()=>editState([index,key]) }"> 
                    <span if="{state.pathstr!=JSON.stringify([index,key]) || (!state.options[key].put)}">{row[key]}</span>
                    <input if="{state.pathstr==JSON.stringify([index,key]) && state.options[key].put  }"
                            class="w-100" id="{'input-control-'+index+'-'+key+'-'+state.pkidstr }" 
                            type="{ getInputType(state.options[key].type) }" value="{state.data[index][key]}" 
                            onchange="{applyPut}" onkeydown="{control}"
                            onblur="{()=>leavetable([index,key])}"/>
                </td>
                <td class="cell-counter border-{state.theme.border} bg-{state.theme.bg} text-{state.theme.text} {state.tableOptions.delete ? 'c-pointer':'' }">
                    <input data-deletekey="{getRowKey(row)}" onclick="{toggleRow}" checked="{getRowKey(row) in state.delete}" type="checkbox"/>
                </td>
            </tr>
            <tr if="{state.mode=='post'}">
                <td onclick="{applyPost}" class="cell-counter cell-post border-{state.theme.border} bg-{state.theme.bg} text-{state.theme.text} c-pointer">
                    <span class="badge badge-secondary">
                        new
                    </span>
                </td>
                <td if="{key in state.options && state.options[key].visible==true}" 
                    each="{key in state.datakeys}" class="{state.theme.matchContents ? 'border-'+state.theme.border : ''} {state.theme.matchContents ? 'bg-'+state.theme.bg : ''} {state.theme.matchContents ? 'text-'+state.theme.text : ''}">
                    <input  id="{'new-insert-'+key}" data-postkey="{key}" class="w-100" 
                            type="{ getInputType(state.options[key].type) }"  
                            onchange="{editPost}" value="{key in state.new ? state.new[key] : null}"/>
                </td>
                <td class="cell-counter border-{state.theme.border} bg-{state.theme.bg} text-{state.theme.text}">
                </td>
            </tr>
        </tbody>
        <tfoot class="bg-{state.theme.bg} text-{state.theme.text}">
            <tr>
                <td class="footer-cell-control border-0" 
                    colspan="1">
                    <span class="badge badge-secondary c-pointer d-none">
                        <div class="rotate-45 bigger">
                            &#9906;
                        </div>
                    </span>
                </td>
                <td class="footer-cell-control" 
                    colspan="{state.datakeys.length-2}">
                    <span>
                        <select onchange="{setPageCount}">
                            <option val="1">1</option>
                            <option val="10" selected>10</option>
                            <option val="25">25</option>
                            <option val="50">50</option>
                            <option val="100">100</option>
                        </select>
                    </span>
                    <span class="ml-3">
                        <button class="footer-pagination-button" if="{state.pagination.page>1}" type="button" onclick="{setPage}" value="1">&#8676;</button>
                        <button class="footer-pagination-button" if="{state.pagination.page>1}" type="button" onclick="{setPage}" value="{state.pagination.page-1}">{state.pagination.page-1}</button>
                        page
                        <input class="footer-cell-control-page-input" type="number" value="{state.pagination.page}" onchange="{setPage}">
                        <button class="footer-pagination-button" if="{state.pagination.page<Math.floor(state.data.length/state.pagination.show)}" type="button" onclick="{setPage}" value="{state.pagination.page+1}">{state.pagination.page+1}</button>
                        <button class="footer-pagination-button" if="{state.pagination.page<Math.floor(state.data.length/state.pagination.show)}" type="button" onclick="{setPage}" value="{Math.ceil(state.data.length/state.pagination.show)}">&#8677;</button>
                        of { state.pagination.max }
                    </span>
                    <span class="ml-3">
                        displaying {state.pagination.start+1} to { state.data.length < state.pagination.end-1 ? state.data.length : state.pagination.end-1 } of { state.data.length }
                    </span>
                </td>
                <td class="cell-counter cell-counter-bottom c-pointer text-right">
                    <span onclick="{postMenu}" if="{state.tableOptions.post}" class="badge badge-success">
                        <span if="{state.mode!='post'}">+</span>
                        <span if="{state.mode=='post'}">x</span>
                    </span>
                </td>
                <td class="cell-counter cell-counter-bottom">
                    <span onclick="{applyDelete}" if="{state.tableOptions.delete && state.deletecnt > 0}" class="badge badge-danger c-pointer position-relative table-action">
                        <span>X</span>
                        <div class="toast position-absolute d-none" >
                            <div class="toast-header">
                                <strong class="mr-auto">To Be Deleted</strong>
                                <small>  Items</small>
                            </div>
                            <div class="toast-body text-muted row-header">
                                The following items will be deleted
                                <ul class="list-group mt-2">
                                    <li class="list-group-item " each="{value in Object.values(state.delete)}">
                                        { JSON.stringify(value) }
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </span>
                </td>
            </tr>
        </tfoot>
    </table>
    <style>
        table { 
            font-size:1rem;
            line-height:1.5rem;
        }
        .table-action .toast{
            right:20px;
            bottom:20px;
        }
        .table-action:hover .toast{
            opacity:1;
        }
        .table-action .list-group {
            max-height:40px;
            overflow:auto;
        }
        .border-dark {
            border-color:#454d55 !important;
        }
        .border-light {
            border-color:#dee2e6 !important;
        }
        .cell-post {
            min-width:45px !important;
            max-width:45px !important;
            width:45px !important;
        }
        .cell-counter {
            min-width:25px;
            max-width:25px;
            width:25px;
            border-bottom:1px solid;
            font-weight:300;
            font-size:.9rem;
            line-height:1.5rem;
            overflow:hidden;
        }
        .cell-counter-bottom {
            border-bottom:none;
        }
        .row-header {
            font-weight:400;
        }
        .row-menu-wrapper {
            position:relative;
            white-space:nowrap;
        }
        .row-menu {
            position:absolute;
            left:20px;
            top:5px; 
        }
        .footer-cell-control {
            outline:none;
            border-top:none !important;
            font-size:.8rem;
            font-weight:300;
            padding-top:.5rem;
            padding-bottom:.5rem;
        }
        .footer-pagination-button {
            height:1.3rem;
            line-height:.9rem;
        }
        .footer-cell-control-page-input{
            width:30px;
            height:1.3rem;
            font-weight:600;
        }   
        .order-desc{
            display:inline-block;
            -webkit-transform: rotateZ(90deg); /* Safari prior 9.0 */
            transform: rotateZ(90deg); /* Standard syntax */
            font-size:.8rem;
        }
        .order-asc{
            display:inline-block;
            -webkit-transform: rotateZ(-90deg); /* Safari prior 9.0 */
            transform: rotateZ(-90deg); /* Standard syntax */
            font-size:.8rem;
        }
        .rotate-45{
            -webkit-transform: rotateZ(45deg); /* Safari prior 9.0 */
            transform: rotateZ(45deg); /* Standard syntax */
        }
        .bigger {
            font-size:.9rem;
        }
        .c-pointer{
            cursor:pointer;
        }
        .widget-grid-header * {
            user-select: none; /* CSS3 (little to no support) */
        -ms-user-select: none; /* IE 10+ */
       -moz-user-select: none; /* Gecko (Firefox) */
    -webkit-user-select: none; /* Webkit (Safari, Chrome) */
        }
        input[type="checkbox"],input[type="radio"]{
            height:15px;
            outline:none!important;
        }
    </style>
    <script>
        export default {
            state : {
                data:[],
                new:{},
                delete:{},
                deletecnt:0,
                path:[],
                pathstr:"",
                datakeys:[],
                shiftmodifier:false,
                tabbed:false,
                pagination:{
                    show:10,
                    page:1,
                    start:0,
                    end:10,
                    max:1,
                },
                callbacks:{},
                options:{},
                tableOptions:{},
                sort:{},
                theme:{},
                mode:"",
                all:false
            },
            preventNextChange:false,
            debugMode:false,
            debug:{
                data:[
                    {
                        "Id":1,
                        "Name":"Ryan",
                        "Age":27,
                        "Email":"test@test.com",
                        "Is":false
                    },{
                        "Id":2,
                        "Name":"Kiichi",
                        "Age":null,
                        "Email":"anothertest@test.com",
                        "Is":true
                    },{
                        "Id":3,
                        "Name":"Justin",
                        "Age":null,
                        "Email":"testing123@test.com",
                        "Is":false
                    },{
                        "Id":4,
                        "Name":"Korey",
                        "Age":null,
                        "Email":"information@test.com",
                        "Is":false
                    },{
                        "Id":5,
                        "Name":"James",
                        "Age":null,
                        "Email":"testinformation@test.com",
                        "Is":false
                    }
                ],
                callbacks:{},
                options:{
                    "Id":{
                        alias:"UserID",
                        pk:true,
                        put:false,
                        visible:false
                    },
                    "Name":{
                        alias:"Involved Person"
                    },
                    "Age":{
                        alias:"Incident Age",
                        type:Number,
                    },
                    "Is":{
                    }
                },
                tableOptions:{
                    post:true,
                    delete:true
                },
                typeSort:{
                    "String":(a,b)=>{
                        return a.localeCompare(b);
                    },
                    "Number":(a,b)=>{
                        a=a==null?-Infinity:a;
                        b=b==null?-Infinity:b;
                        let result = parseFloat(a)-parseFloat(b);
                        if(isNaN(result)){
                            return 0;
                        }
                        else{
                            result=result==-Infinity?-1:result;
                            result=result==Infinity?1:result;
                            return result;
                        }
                    },
                    "Date":(a,b)=>{
                        return a-b;
                    },
                    "Boolean":(a,b)=>{
                        return a-b;
                    }
                },
                theme:{
                    bg:"light",
                    border:"light",
                    text:"dark",
                    matchContents:true
                }
            },
            defaults:{
                data:[],
                callbacks:{
                    put:(updated)=> console.log(updated),
                    post:(created)=> console.log(created),
                    delete:(deleted)=> console.log(deleted)
                },
                options:{
                    alias:null,
                    type:String,
                    autotype:(value)=>{return value.constructor},
                    visible:true,
                    put:true,
                    pk:false,
                    sort:null
                },
                tableOptions:{
                    delete:true,
                    post:true
                },
                typeSort:{
                    "String":(a,b)=>{
                        return a.localeCompare(b);
                    },
                    "Number":(a,b)=>{
                        a=a==null?-Infinity:a;
                        b=b==null?-Infinity:b;
                        let result = parseFloat(a)-parseFloat(b);
                        if(isNaN(result)){
                            return 0;
                        }
                        else{
                            result=result==-Infinity?-1:result;
                            result=result==Infinity?1:result;
                            return result;
                        }
                    },
                    "Date":(a,b)=>{
                        return a-b;
                    },
                    "Boolean":(a,b)=>{
                        return a-b;
                    }
                },
                theme:{
                    bg:"light",
                    border:"light",
                    text:"dark",
                    matchContents:true
                }
            },
            windowkeyup:null,
            windowkeydown:null,
            onBeforeMount(props,state){
                props = this.debugMode ? this.debug : props;
                this.windowkeyup = window.addEventListener("keyup",(e)=>this.controlModifier(e));
                this.windowkeydown = window.addEventListener("keydown",(e)=>this.controlModifier(e));
                // set underlying table data
                this.state.data = props.data || this.state.data;

                // set initial data keys                
                this.state.datakeys = this.state.data.length > 0 ? Object.keys(this.state.data[0]) : Object.keys(props.options) ;

                // set table operation callbacks - functions cannot use assign
                let callbacks = Object.assign({},this.defaults.callbacks);
                Object.keys(callbacks).forEach((callback)=>{
                    callbacks[callback] = props.callbacks && props.callbacks[callback] ? props.callbacks[callback] : callbacks[callback] ;
                });
                this.state.callbacks=callbacks;
                // set column options (autotype, typeoverride, visible, insert, update, delete, pk)
                /* setting column options requires iterating through data's key, determinine generic autotype and overriding with users entered overrides via props */
                this.state.datakeys.forEach((key)=>{
                    let columnOptions=Object.assign({},this.defaults.options);
                    
                    Object.keys(columnOptions).forEach((optionname)=>{
                        columnOptions[optionname] = props.options[key] && optionname in props.options[key] ? props.options[key][optionname] : columnOptions[optionname];
                    });

                    if(!(key in props.options) || !props.options[key].type ){
                        let i=0; //search until first auto-type is found for col not null
                        let autotype=null;
                        while(autotype==null && i<this.state.data.length){
                            if(this.state.data[i][key]!=null){
                                columnOptions.autotype=columnOptions.autotype(this.state.data[i][key]);
                                autotype=true;
                            }
                            i++;
                        }
                        columnOptions.type=columnOptions.autotype;
                    }
                    
                    this.state.options[key] = columnOptions; // set column options
                });

                // set table options (post,delete)
                this.state.tableOptions = Object.assign({},this.defaults.tableOptions);
                this.state.tableOptions = props.tableOptions ? Object.assign(this.state.tableOptions,props.tableOptions):this.state.tableOptions; 

                // set typeSort options
                this.state.typeSort = Object.assign({},this.defaults.typeSort);
                this.state.typeSort = props.typeSort ? Object.assign(this.state.typeSort,props.typeSort) : this.state.typeSort;
                
                //set theme options
                this.state.theme = Object.assign({},this.defaults.theme);
                this.state.theme = props.theme ? Object.assign(this.state.theme,props.theme): this.state.theme;

                this.state.pkidarr = this.getPKID();
                this.state.pkidstr = this.state.pkidarr.join('-');
            },
            onBeforeUnmount(){
                window.removeEventListener(this.windowkeyup);
                window.removeEventListener(this.windowkeydown);
            },
            getPKID(){
                let PKID = [];
                this.state.datakeys.forEach((key)=>{
                    this.state.options[key].pk ? PKID.push(key) : 0 ;

                })
                return PKID;
            },
            getInputType(type){
                if(type===String){
                    return 'textbox';
                }
                else if(type===Number){
                    return 'number'; 
                }
                else if(type===Date){
                    return 'datetime';
                }
                else if(type===Boolean){
                    return 'checkbox';
                }
            },
            getInputGetMethod(type){
                if(type===String){
                    return (e)=>{
                        return e.target.value; 
                    };
                }
                else if(type===Number){
                    return (e)=>{
                        return e.target.value; 
                    };
                }
                else if(type===Date){
                    return (e)=>{
                        return e.target.value; 
                    };
                }
                else if(type===Boolean){
                    return (e)=>{
                        return e.target.checked; 
                    };
                }
            },
            getInputSetMethod(type){
                if(type===String){
                    return (el,val)=>{
                        el.value; 
                    };
                }
                else if(type===Number){
                    return (el,val)=>{
                        el.value=val; 
                    };
                }
                else if(type===Date){
                    return (el,val)=>{
                        el.value=val; 
                    };
                }
                else if(type===Boolean){
                    return (el,val)=>{
                        el.checked=val; 
                    };
                }
            },
            getRowKey(row){
                return this.state.pkidarr.map(( pkid )=>{ return pkid+'_'+row[pkid] }).join('-');
            },
            parseColType(str,col){
                let type=this.state.options[col].type;
                if(type===Number){

                    return str.type===String  ? parseFloat(str) : str;
                }
                else if(type===String){
                    return str.type===String ? str : str + "";
                }
                else if(type===Date){
                    return str;
                }
                else if(type===Boolean){
                    return str=="true" || str == 1 ? true : false
                }
            },
            parseRowKey(rowkey){
                let rowkeyobj={};
                rowkey.split("-").forEach((key)=>{
                    let keypair = key.split("_");
                    rowkeyobj[keypair[0]]=this.parseColType(keypair[1],keypair[0]);
                });
                return rowkeyobj;
            },
            setPage(e){
                if(e.target.value<1){
                    this.state.pagination.page=1;
                    this.state.pagination.start = (this.state.pagination.show*0);
                    this.state.pagination.end = (this.state.pagination.show*1);
                    this.state.pagination.max = Math.ceil(this.state.data.length/this.state.pagination.show);
                }
                else{
                    this.state.pagination.page = parseInt(e.target.value);
                    this.state.pagination.start = (this.state.pagination.show*(this.state.pagination.page))-this.state.pagination.show;
                    this.state.pagination.end = (this.state.pagination.show*this.state.pagination.page)+1;
                    this.state.pagination.max = Math.ceil(this.state.data.length/this.state.pagination.show);
                }
                this.update();
            },
            setPageCount(e){
                this.state.pagination.show = parseInt(e.target.value);
                let mockevent = {target:{value:"1"}};
                this.setPage(mockevent);
            },
            getSelected(){
                return Object.keys(this.state.delete);
            },
            rowMenu(e){
                if(this.state.tableOptions.delete){
                    if(e.target.getAttribute("style")==null){
                        e.target.setAttribute('style','min-width:100px');
                        this.state.mode="modify";
                    }
                    else{
                        let counters = document.getElementsByClassName("cell-counter");
                        for(var i=0;i<counters.length;i++){
                            counters[0].removeAttribute("style");
                        }
                        this.state.mode="";
                    }
                    this.update();
                }
            },
            toggleAll(e){
                if(this.state.all){
                    this.state.all=false;
                    this.state.delete={};
                    this.state.deletecnt=0;
                }
                else{
                    for(var i=0;i<this.state.data.length;i++){
                        let rowpairkey = this.getRowKey(this.state.data[i]);
                        let rowkeyobj = this.parseRowKey(rowpairkey);
                        this.state.delete[rowpairkey]=rowkeyobj;
                    }
                    this.state.all=true;
                    this.state.deletecnt=this.state.data.length;
                }
                this.update();
            },
            toggleRow(e){
                let rowpairkey= e.target.getAttribute("data-deletekey");
                let rowkeyobj=this.parseRowKey(rowpairkey);
                if(rowpairkey in this.state.delete){
                    //remove item
                    this.state.all=false;
                    delete this.state.delete[rowpairkey];
                }
                else{
                    //add item (check if all selected)
                    this.state.delete[rowpairkey]=rowkeyobj;
                    if(Object.keys(this.state.delete).length== this.state.data.length){
                        this.state.all=true;
                    }
                }
                this.state.deletecnt=Object.keys(this.state.delete).length;
                this.update();
                /*  Inverse add logic
                    let add = false;
                    rowkeys.forEach((key)=>{
                        if(this.state.data[i][key]!=rowkeyobj[key]){
                            add=true;
                        }
                    });
                    if(add){

                    }
                */
            },
            postMenu(e){
                this.state.mode = this.state.mode=="post"?"":"post";
                this.update();
            },
            isVisible(rowIndex){
                return (
                    rowIndex+1 > this.state.pagination.start &&
                    rowIndex+1 < this.state.pagination.end
                );
            },
            control(e){
                if(e.key == "Tab" || e.key =="ArrowDown"){
                    e.preventDefault();
                }
                let datakeys=this.state.datakeys;
                let rowpathindex=this.state.path.length-2;
                let keypathindex=this.state.path.length-1;
                let curkey= this.state.path[keypathindex];
                let curkeyindex;
                let rowindex= this.state.path[rowpathindex];
                let curpath = JSON.parse(JSON.stringify(this.state.path));
                this.state.datakeys.forEach((key,index)=>{
                    if(key==curkey){
                        curkeyindex=index;
                    }
                })
                if(curkeyindex===undefined || curkeyindex==null){
                    rowindex < this.state.data.length-1  ? curpath[rowpathindex]++ : 0
                    curkeyindex=0;
                }
                if(e.key == "Tab"){
                    this.applyPut(e,true);
                    if(this.state.shiftmodifier){
                        if(curkeyindex==0){
                            rowindex == 0  ? curpath[rowpathindex]=this.state.data.length-1 : curpath[rowpathindex]-- ;
                        }
                        else{
                            curkeyindex--
                        }
                    }
                    else{   
                        if(curkeyindex<datakeys.length-1){
                            curkeyindex++
                        }
                        else{
                            curkeyindex=0;
                            rowindex < this.state.data.length-1  ? curpath[rowpathindex]++ : 0
                        } 
                    }
                    curpath[keypathindex]=datakeys[curkeyindex];
                    this.editState(curpath,true);
                }
                if(e.key == "Enter" || e.key == "ArrowDown") {
                    this.applyPut(e,true);
                    rowindex < this.state.data.length-1  ? curpath[rowpathindex]++ : 0
                    this.editState(curpath,true)
                }
                if(e.key == "ArrowUp"){
                    this.applyPut(e,true);
                    rowindex == 0 ? curpath[rowpathindex] = this.state.data.length-1 : curpath[rowpathindex]--;
                    this.editState(curpath,true);
                }
                if(e.key == "Escape"){
                    this.editState([]);
                }
            },
            controlModifier(e){
                if(e.key=="Shift"){
                    if(e.type=="keydown"){
                        this.state.shiftmodifier=true;
                    }
                    else if(e.type=="keyup"){
                        this.state.shiftmodifier=false;
                    }
                }
            },
            leavetable(path){
                let oldvalue = JSON.stringify(path);
                setTimeout(()=>{
                    oldvalue == this.state.pathstr ? this.editState([]) : false ;
                },200)
            },
            editState(path){
                let exists = this.state.pathstr != JSON.stringify(path) && JSON.stringify(path) !="[]";
                this.state.path=path;
                this.state.pathstr=JSON.stringify(path);
                this.update();
                if(exists){
                    let id = '#input-control-'+path[path.length-2]+'-'+path[path.length-1]+'-'+this.getPKID().join("-");
                    if(path.length>0){
                        let type = this.state.options[path[1]].type;
                        let setter = this.getInputSetMethod(type);
                        let input = this.$(id);
                        let value = this.state.data[path[0]][path[1]];
                        setter(input,value);
                        if(input){
                            input.focus();
                            input.select();
                        }
                    }
                }
            },
            applyPut(e,preventNextChange=false){
                let path = this.state.path;
                if(path.length>0 && this.preventNextChange==false){
                    let type = this.state.options[path[1]].type;
                    let getter = this.getInputGetMethod(type);
                    let old=JSON.parse(JSON.stringify(this.state.data[path[0]]));
                    this.state.data[path[0]][path[1]] = getter(e);
                    if(JSON.stringify(old)!=JSON.stringify(this.state.data[path[0]])){
                        this.state.callbacks.put({
                            pkid:this.getPKID(),
                            type:"put",
                            old:old,
                            new:this.state.data[path[0]]
                        });
                    }
                    this.preventNextChange=preventNextChange;
                    this.update();
                }
                else{
                    this.preventNextChange=false;
                }
            },
            editPost(e){
                //save postable content to object to send
                let key = e.target.getAttribute("data-postkey");
                let type = this.state.options[key].type;
                let getter = this.getInputGetMethod(type);
                this.state.new[key]=getter(e);
            },
            applyPost(e){
                //send object to post callback
                let postback = JSON.parse(JSON.stringify(this.state.new));
                let postbackPKID = this.getPKID();
                let postbackPKIDObj = {};
                postbackPKID.forEach((pkid)=>{
                    postbackPKIDObj[pkid]=null;
                });

                let confirmPost = (PKIDMergeObj)=>{
                    this.state.data.push(Object.assign(postback,PKIDMergeObj));
                    this.state.datakeys.forEach((key)=>{
                        let input = this.$('#new-insert-'+key);
                        input !== undefined ? input.value='':0;

                    })
                    this.state.new={};
                    this.update();
                    return confirmPost;
                }

                if(this.debugMode){
                    postbackPKID.forEach((pkcol)=>{
                        postbackPKIDObj[pkcol] = this.uuidv4();
                    });
                } 
                this.state.callbacks.post({
                    pkid:postbackPKID,
                    type:"post",
                    new:postback,
                    confirmContent:postbackPKIDObj,
                    confirm: ( this.debugMode ? confirmPost( postbackPKIDObj ) : confirmPost )
                });
            },
            applyDelete(e){
                let deletekeys=Object.keys(this.state.delete).map((key)=>this.state.delete[key]);

                e.preventDefault();
                e.stopPropagation();

                let confirmdelete = (result,callback=(deleted,deletekeys)=>{ console.log("client side delete failed",deleted,deletekeys) })=>{
                        if(result){
                            let deleted=[];
                            for(var i=0;i<this.state.data.length;i++){
                                let match=false;
                                deletekeys.forEach((deletekey)=>{
                                    let keymatch=true;
                                    Object.keys(deletekey).forEach((key)=>{
                                        if(this.state.data[i][key]!=deletekey[key]){
                                            keymatch=false;
                                        }
                                    })
                                    if(keymatch){
                                        match=true;
                                    }
                                });
                                if(match){
                                    deleted.push(this.state.data[i]);
                                    this.state.data.splice(i,1);
                                    i--;
                                }
                            }
                            if(deleted.length!=deletekeys.length){
                                callback(deleted,deletekeys);
                            }
                            this.update();
                        }
                        return confirmdelete;
                    };

                this.state.callbacks.delete({
                    old: deletekeys,
                    type:"delete",
                    confirm: (this.debugMode ? confirmdelete(true) : confirmdelete)  
                })
            },
            uuidv4() {
                return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                })
            },  
            sort(key){
                var numsorts = this.calcSortOrder();
                let oldkey = key in this.state.sort && this.state.sort[key].type ? this.state.sort[key].type :"NONE";
                if(!this.state.shiftmodifier){
                    this.state.sort={};
                    this.state.sort[key]={
                        type:oldkey,
                        order:0
                    }
                }
                if(this.state.sort[key]===undefined){
                    this.state.sort[key]={
                        type:"DESC",
                        order:numsorts.length-1
                    }
                } 
                else if(this.state.sort[key].type=="NONE"){
                    this.state.sort[key].type="DESC";
                }
                else if(this.state.sort[key].type=="DESC"){
                    this.state.sort[key].type="ASC";
                }
                else if(this.state.sort[key].type=="ASC"){
                    delete this.state.sort[key];
                }

                var finalsortorder=this.calcSortOrder();
                this.buildSort(finalsortorder);
                this.update();
            },
            calcSortOrder(){
                var numsorts = Object.keys(this.state.sort);
                for(var i=0;i<numsorts.length-1;i++){
                    if(this.state.sort[numsorts[i]].order > this.state.sort[numsorts[i+1]].order){
                        let forward = numsorts[i];
                        numsorts=numsorts.splice(i,1,numsorts[i+1]);
                        numsorts[i+1]=forward;
                    }
                }
                for(var i=0;i<numsorts.length;i++){
                    this.state.sort[numsorts[i]].order=i;
                }
                return numsorts;
            },
            buildSort(orderedsorts){
                var thisref=this;
                function dimensionalSort(dimensionalsorts, dimensionalindex=0,a,b){
                    if(dimensionalindex<dimensionalsorts.length){
                        let key=dimensionalsorts[dimensionalindex];
                        let sortresult=thisref.state.typeSort[thisref.state.options[key].type.name](a[key],b[key]);
                        sortresult = thisref.state.sort[key].type=="ASC" ? sortresult : -1 * sortresult;
                        dimensionalindex++;
                        return sortresult==0 ? dimensionalSort(dimensionalsorts,dimensionalindex,a,b) : sortresult;
                    }
                    return 0;
                }
                this.state.data = this.state.data.sort((a,b)=>{ 
                    return dimensionalSort(orderedsorts,0,a,b);
                });
            }
        }
    </script>
</widget-grid>