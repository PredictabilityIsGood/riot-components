<widget-grid>
        <table class="p-0 m-0 table table-hover table-sm" onkeyup="{controlModifier}" onkeydown="{controlModifier}">
            <thead class="widget-grid-header thead-{state.theme.bg}">
                <tr>
                    <th class="cell-counter border-{state.theme.border} text-muted">#</th>
                    <th onclick="{()=>sort(key)}" class="c-pointer button-{state.theme.bg} text-{state.theme.text} row-header" if="{key in state.options && state.options[key].visible==true}" each="{key in state.datakeys}" scope="col">{state.options[key].alias || key} 
                        <span class="float-right w-0">
                            <span if="{state.sort[key] && state.sort[key].type=='DESC'}" id="{key+'-DESC'}" class="order-desc">
                                    &#10142;
                            </span>
                            <span if="{state.sort[key] && state.sort[key].type=='ASC'}" id="{key+'-ASC'}" class="order-asc">
                                    &#10142;
                            </span>
                        </span>
                    </th>
                    <th class="cell-counter border-{state.theme.border} text-muted">
                        <input onclick="{toggleAll}" type="checkbox" checked="{state.all}"/>
                    </th>
                </tr>
            </thead>
            <tbody>
                <tr if="{isVisible(index)}" each="{(row,index) in state.data}">
                    <td class="cell-counter border-{state.theme.border} bg-{state.theme.bg} text-{state.theme.text}">
                        <span class="row-menu-wrapper">
                            {index+1}
                        </span>
                    </td>
                    <td if="{key in state.options && state.options[key].visible==true}" 
                        class="c-pointer {state.theme.matchContents ? 'border-'+state.theme.border : ''} {state.theme.matchContents ? 'bg-'+state.theme.bg : ''} {state.theme.matchContents ? 'text-'+state.theme.text : ''}" 
                        each="{key in state.datakeys}" onclick="{ ()=>editState([index,key]) }"> 
                        <span if="{state.pathstr!=JSON.stringify([index,key]) || (!state.options[key].put) || (!state.tableOptions.put)}">{row[key]}</span>
                        <input if="{state.pathstr==JSON.stringify([index,key]) && state.options[key].put && state.tableOptions.put  }"
                                class="w-100" id="{'input-control-'+index+'-'+key+'-'+state.pkidstr }" 
                                type="{ getInputType(state.options[key].type) }" value="{state.data[index][key]}" 
                                onchange="{applyPut}" onkeydown="{control}"
                                onblur="{()=>leavetable([index,key])}"/>
                    </td>
                    <td class="cell-counter border-{state.theme.border} bg-{state.theme.bg} text-{state.theme.text} {state.tableOptions.delete ? 'c-pointer':'' }">
                        <input data-selectkey="{getRowKey(row)}" onclick="{toggleRow}" checked="{getRowKey(row) in state.selected}" type="checkbox"/>
                    </td>
                </tr>
                <tr if="{state.mode=='post'}">
                    <td onclick="{applyPost}" class="cell-counter cell-post border-{state.theme.border} bg-{state.theme.bg} text-{state.theme.text} c-pointer">
                        <span class="badge badge-secondary">
                            new
                        </span>
                    </td>
                    <td if="{key in state.options && state.options[key].visible==true}" 
                        each="{key in state.datakeys}" class="{state.theme.matchContents ? 'border-'+state.theme.border : ''} {state.theme.matchContents ? 'bg-'+state.theme.bg : ''} {state.theme.matchContents ? 'text-'+state.theme.text : ''}">
                        <input  id="{'new-insert-'+key}" data-postkey="{key}" class="w-100" 
                                type="{ getInputType(state.options[key].type) }"  
                                onchange="{editPost}" value="{key in state.new ? state.new[key] : null}"/>
                    </td>
                    <td class="cell-counter border-{state.theme.border} bg-{state.theme.bg} text-{state.theme.text}">
                    </td>
                </tr>
            </tbody>
            <tfoot class="bg-{state.theme.bg} text-{state.theme.text}">
                <tr if="{state.tableOptions.footer}">
                    <td class="footer-cell-control border-0" 
                        colspan="1">
                        <span class="badge badge-secondary c-pointer d-none">
                            <div class="rotate-45 bigger">
                                &#9906;
                            </div>
                        </span>
                    </td>
                    <td  class="footer-cell-control" 
                        colspan="{visibleCols()}">
                        <span if="{state.tableOptions.pagination}">
                            <span>
                                <select onchange="{setPageCount}">
                                    <option val="1">1</option>
                                    <option val="10" selected>10</option>
                                    <option val="25">25</option>
                                    <option val="50">50</option>
                                    <option val="100">100</option>
                                </select>
                            </span>
                            <span class="ml-3">
                                <button class="footer-pagination-button" if="{state.pagination.page>1}" type="button" onclick="{setPage}" value="1">&#8676;</button>
                                <button class="footer-pagination-button" if="{state.pagination.page>1}" type="button" onclick="{setPage}" value="{state.pagination.page-1}">{state.pagination.page-1}</button>
                                page
                                <input class="footer-cell-control-page-input" type="number" value="{state.pagination.page}" onchange="{setPage}">
                                <button class="footer-pagination-button" if="{state.pagination.page<Math.floor(state.data.length/state.pagination.show)}" type="button" onclick="{setPage}" value="{state.pagination.page+1}">{state.pagination.page+1}</button>
                                <button class="footer-pagination-button" if="{state.pagination.page<Math.floor(state.data.length/state.pagination.show)}" type="button" onclick="{setPage}" value="{Math.ceil(state.data.length/state.pagination.show)}">&#8677;</button>
                                of { state.pagination.max }
                            </span>
                            <span class="ml-3">
                                displaying {state.pagination.start+1} to { state.data.length < state.pagination.end-1 ? state.data.length : state.pagination.end-1 } of { state.data.length }
                            </span>
                        </span>
                    </td>
                    <td class="cell-counter cell-counter-bottom c-pointer text-right">
                        <span onclick="{postMenu}" if="{state.tableOptions.post}" class="badge badge-success">
                            <span if="{state.mode!='post'}">+</span>
                            <span if="{state.mode=='post'}">x</span>
                        </span>
                    </td>
                    <td class="cell-counter cell-counter-bottom">
                        <span onclick="{applyDelete}" if="{state.tableOptions.delete && state.selectedcnt > 0}" class="badge badge-danger c-pointer position-relative table-action">
                            <span>X</span>
                            <div class="toast position-absolute d-none" >
                                <div class="toast-header">
                                    <strong class="mr-auto">To Be Deleted</strong>
                                    <small>  Items</small>
                                </div>
                                <div class="toast-body text-muted row-header">
                                    The following items will be deleted
                                    <ul class="list-group mt-2">
                                        <li class="list-group-item " each="{value in Object.values(state.selected)}">
                                            { JSON.stringify(value) }
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </span>
                    </td>
                </tr>
            </tfoot>
        </table>
        <style>
            table { 
                font-size:1rem;
                line-height:1.5rem;
            }
            .table-action .toast{
                right:20px;
                bottom:20px;
            }
            .table-action:hover .toast{
                opacity:1;
            }
            .table-action .list-group {
                max-height:40px;
                overflow:auto;
            }
            .border-dark {
                border-color:#454d55 !important;
            }
            .border-light {
                border-color:#dee2e6 !important;
            }
            .cell-post {
                min-width:45px !important;
                max-width:45px !important;
                width:45px !important;
            }
            .cell-counter {
                min-width:25px;
                max-width:25px;
                width:25px;
                border-bottom:1px solid;
                font-weight:300;
                font-size:.9rem;
                line-height:1.5rem;
                overflow:hidden;
            }
            .cell-counter-bottom {
                border-bottom:none;
            }
            .row-header {
                font-weight:400;
            }
            .row-menu-wrapper {
                position:relative;
                white-space:nowrap;
            }
            .row-menu {
                position:absolute;
                left:20px;
                top:5px; 
            }
            .footer-cell-control {
                outline:none;
                border-top:none !important;
                font-size:.8rem;
                font-weight:300;
                padding-top:.5rem;
                padding-bottom:.5rem;
            }
            .footer-pagination-button {
                height:1.3rem;
                line-height:.9rem;
            }
            .footer-cell-control-page-input{
                width:30px;
                height:1.3rem;
                font-weight:600;
            }   
            .order-desc{
                display:inline-block;
                -webkit-transform: rotateZ(90deg); /* Safari prior 9.0 */
                transform: rotateZ(90deg); /* Standard syntax */
                font-size:.8rem;
            }
            .order-asc{
                display:inline-block;
                -webkit-transform: rotateZ(-90deg); /* Safari prior 9.0 */
                transform: rotateZ(-90deg); /* Standard syntax */
                font-size:.8rem;
            }
            .rotate-45{
                -webkit-transform: rotateZ(45deg); /* Safari prior 9.0 */
                transform: rotateZ(45deg); /* Standard syntax */
            }
            .bigger {
                font-size:.9rem;
            }
            .c-pointer{
                cursor:pointer;
            }
            .widget-grid-header * {
                user-select: none; /* CSS3 (little to no support) */
            -ms-user-select: none; /* IE 10+ */
            -moz-user-select: none; /* Gecko (Firefox) */
        -webkit-user-select: none; /* Webkit (Safari, Chrome) */
            }
            input[type="checkbox"],input[type="radio"]{
                height:15px;
                outline:none!important;
            }
            .table-hover tbody tr:hover td {
                background-color:rgba(0,0,0,.075)!important;
            }
        </style>
        <script>
            export default {
                state: {
                    data:[],
                    new:{},
                    selected:{},
                    selectedcnt:0,
                    path:[],
                    pathstr:"",
                    datakeys:[],
                    shiftmodifier:false,
                    tabbed:false,
                    pagination:{},
                    callbacks:{},
                    options:{},
                    tableOptions:{},
                    sort:{},
                    theme:{},
                    firstRun:true,
                    mode:"",
                    all:false,                
                    preventNextChange:false
                },
                debugMode:false,
                debug:{
                    data:[
                            {
                                "Id":1,
                                "Name":"Ryan",
                                "Age":27,
                                "Email":"test@test.com",
                                "Is":false,
                                "StartDate":"2018-01-01T00:00:01",
                                "State":"NY",
                                "City":"Glen Cove",
                                "Address":"100 Test Street",
                                "Sex":"M"
                            },{
                                "Id":2,
                                "Name":"Kiichi",
                                "Age":null,
                                "Email":"anothertest@test.com",
                                "Is":true,
                                "StartDate":"2002-01-01T00:00:01",
                                "State":"NY",
                                "City":"Test City",
                                "Address":"200 Test Street",
                                "Sex":"M"
                            },{
                                "Id":3,
                                "Name":"Justin",
                                "Age":null,
                                "Email":"testing123@test.com",
                                "Is":false,
                                "StartDate":"2018-01-01T00:00:01",
                                "State":"NY",
                                "City":"Another Test City",
                                "Address":"100 Test Street",
                                "Sex":"M"
                            },{
                                "Id":4,
                                "Name":"Korey",
                                "Age":null,
                                "Email":"information@test.com",
                                "Is":false,
                                "StartDate":null,
                                "State":"NY",
                                "City":"Another Test City",
                                "Address":"150 Test Street",
                                "Sex":"M"
                            },{
                                "Id":5,
                                "Name":"James",
                                "Age":null,
                                "Email":"testinformation@test.com",
                                "Is":false,
                                "StartDate":null,
                                "State":"NJ",
                                "City":"Cityopolis",
                                "Address":"100 Test Street",
                                "Sex":"M"
                            }
                        ],
                    callbacks:{},
                    options:{
                        "Id":{
                            alias:"UserID",
                            pk:true,
                            put:false,
                            visible:false
                        },
                        "Name":{
                            alias:"Involved Person"
                        },
                        "Age":{
                            alias:"Incident Age",
                            type:Number,
                        },
                        "Is":{
                        },
                        "StartDate":{
                            externalInput:"#start-date",
                            visible:false
                        },
                        "State":{
                            externalInput:"#state-input",
                            visible:false
                        },
                        "City":{
                            externalInput:"#city-input",
                            visible:false
                        },
                        "Address":{
                            externalInput:"#address-input",
                            visible:false
                        },
                        "Sex":{
                            externalInput:"#sex-input",
                            visible:false
                        }
                    },
                    tableOptions:{
                        put:true,
                        post:true,
                        delete:true
                    },
                    typeSort:{
                        "String":(a,b)=>{
                            return a.localeCompare(b);
                        },
                        "Number":(a,b)=>{
                            a=a==null?-Infinity:a;
                            b=b==null?-Infinity:b;
                            let result = parseFloat(a)-parseFloat(b);
                            if(isNaN(result)){
                                return 0;
                            }
                            else{
                                result=result==-Infinity?-1:result;
                                result=result==Infinity?1:result;
                                return result;
                            }
                        },
                        "Date":(a,b)=>{
                            return a-b;
                        },
                        "Boolean":(a,b)=>{
                            return a-b;
                        }
                    },
                    theme:{
                        bg:"light",
                        border:"light",
                        text:"dark",
                        matchContents:true
                    }
                },
                defaults:{
                    data:[],
                    callbacks:{
                        put:(updated)=> console.log(updated),
                        post:(created)=> console.log(created),
                        delete:(deleted)=> console.log(deleted)
                    },
                    options:{
                        alias:null,
                        type:String,
                        autotype:(value)=>{return value.constructor},
                        visible:true,
                        put:true,
                        pk:false,
                        externalInput:false,
                        sort:null
                    },
                    tableOptions:{
                        put:true,
                        delete:true,
                        post:true,
                        pagination:true,
                        footer:true
                    },
                    typeSort:{
                        "String":(a,b)=>{
                            return a.localeCompare(b);
                        },
                        "Number":(a,b)=>{
                            a=a==null?-Infinity:a;
                            b=b==null?-Infinity:b;
                            let result = parseFloat(a)-parseFloat(b);
                            if(isNaN(result)){
                                return 0;
                            }
                            else{
                                result=result==-Infinity?-1:result;
                                result=result==Infinity?1:result;
                                return result;
                            }
                        },
                        "Date":(a,b)=>{
                            return a-b;
                        },
                        "Boolean":(a,b)=>{
                            return a-b;
                        }
                    },
                    theme:{
                        bg:"light",
                        border:"light",
                        text:"dark",
                        matchContents:true
                    }
                },
                windowkeyup:null,
                windowkeydown:null,
                onBeforeMount(props,state){
                    this.state.selected={};
                    this.state.selectedcnt=0;
                    this.state.options = {};
                    this.state.tableOptions = {};
                    this.state.sort = {};
                    this.state.theme = {};
                    this.state.pagination = {
                        show:10,
                        page:1,
                        start:0,
                        end:10,
                        max:1,
                    };
                    
                    if(props.debugMode==true){
                        this.debugMode=props.debugMode;
                        console.log(this," - debug mode on (widget-grid)");
                        if(props.debug){
                            this.debug=props.debug;
                        }
                    }

                    let configuration = this.debugMode ? this.debug : props;
                    this.windowkeyup = (e)=>this.controlModifier(e);
                    window.addEventListener("keyup",this.windowkeyup);
                    this.windowkeydown = (e)=>this.controlModifier(e);
                    window.addEventListener("keydown",this.windowkeydown);
                    
    
                    // set underlying table data
                    this.state.data = configuration.data || this.debug.data;
    
                    // set initial data keys                
                    this.state.datakeys = this.state.data.length > 0 ? Object.keys(this.state.data[0]) : Object.keys(configuration.options) ;
    
                    // set table operation callbacks - functions cannot use assign
                    let callbacks = Object.assign({},this.defaults.callbacks);
                    Object.keys(callbacks).forEach((callback)=>{
                        callbacks[callback] = configuration.callbacks && configuration.callbacks[callback] ? configuration.callbacks[callback] : callbacks[callback] ;
                    });
                    this.state.callbacks=callbacks;
                    // set column options (autotype, typeoverride, visible, insert, update, delete, pk)
                    /* setting column options requires iterating through data's key, determinine generic autotype and overriding with users entered overrides via props */
                    
                    this.state.datakeys.forEach((key)=>{
                        let columnOptions=Object.assign({},this.defaults.options);
                        
                        Object.keys(columnOptions).forEach((optionname)=>{
                            columnOptions[optionname] = configuration.options[key] && optionname in configuration.options[key] ? configuration.options[key][optionname] : columnOptions[optionname];
                        });
    
                        if(!(key in configuration.options) || !configuration.options[key].type ){
                            let i=0; //search until first auto-type is found for col not null
                            let autotype=null;
                            while(autotype==null && i<this.state.data.length){
                                if(this.state.data[i][key]!=null){
                                    columnOptions.autotype=columnOptions.autotype(this.state.data[i][key]);
                                    autotype=true;
                                }
                                i++;
                            }
                            columnOptions.type=columnOptions.autotype;
                        }
                        this.state.options[key] = columnOptions; // set column options
                        //mount external input change events
                        let externalInput=this.state.options[key].externalInput;
                        if(externalInput){
                            let el = document.querySelector(externalInput);
                            
                            el.addEventListener("change",this.applyPutExternal);  
                        }
                    });
    
                    // set table options (post,delete)
                    this.state.tableOptions = Object.assign({},this.defaults.tableOptions);
                    this.state.tableOptions = configuration.tableOptions ? Object.assign(this.state.tableOptions,configuration.tableOptions):this.state.tableOptions; 
    
                    // set typeSort options
                    this.state.typeSort = Object.assign({},this.defaults.typeSort);
                    this.state.typeSort = configuration.typeSort ? Object.assign(this.state.typeSort,configuration.typeSort) : this.state.typeSort;
                    
                    //set theme options
                    this.state.theme = Object.assign({},this.defaults.theme);
                    this.state.theme = configuration.theme ? Object.assign(this.state.theme,configuration.theme): this.state.theme;
    
                    //set pkcols
                    this.state.pkcols = this.getPKID();
                    this.state.pkidstr = this.state.pkcols.join('-');
    
                    if(configuration.path && this.state.firstRun){
                        this.state.path=configuration.path;
                        this.state.pathstr=JSON.stringify(configuration.path);
                        let path= this.state.path;
                        this.state.firstRun=false;
                        setTimeout(()=>{
                            let id = '#input-control-'+path[path.length-2]+'-'+path[path.length-1]+'-'+this.getPKID().join("-");
                            if(path.length>0){
                                let type = this.state.options[path[1]].type;
                                let setter = this.getInputSetMethod(type);
                                let input = this.$(id);
                                let value = this.state.data[path[0]][path[1]];
                                setter(input,value);
                                if(input){
                                    input.focus();
                                    input.select();
                                }
                            }
                        },50);
                    }
                },
                onBeforeUnmount(){
                    this.state.datakeys.forEach((key)=>{
                        let externalInput = this.state.options[key].externalInput;
                        if(externalInput){
                            let el = document.querySelector(externalInput);
                            el ? el.removeEventListener("change",this.applyPutExternal) : 0 ;
                        }
    
                    })
                    if(this.windowkeyup){
                        window.removeEventListener("keyup",this.windowkeyup);
                        window.removeEventListener("keydown",this.windowkeydown);
                    }
                    else{
                        console.log(this.windowkeyup,"keyevents wiped prior to app mount");
                    }
                },
                getPKID(){
                    let PKID = [];
                    this.state.datakeys.forEach((key)=>{
                        this.state.options[key].pk ? PKID.push(key) : 0 ;
                    })
                    return PKID;
                },
                getInputType(type){
                    if(type===String){
                        return 'textbox';
                    }
                    else if(type===Number){
                        return 'number'; 
                    }
                    else if(type===Date){
                        return 'datetime';
                    }
                    else if(type===Boolean){
                        return 'checkbox';
                    }
                },
                getInputGetMethod(type){
                    if(type===String){
                        return (e)=>{
                            return e.target.value; 
                        };
                    }
                    else if(type===Number){
                        return (e)=>{
                            return e.target.value; 
                        };
                    }
                    else if(type===Date){
                        return (e)=>{
                            return e.target.value; 
                        };
                    }
                    else if(type===Boolean){
                        return (e)=>{
                            return e.target.checked; 
                        };
                    }
                },
                getInputSetMethod(type){
                    if(type===String){
                        return (el,val)=>{
                            el.value=val; 
                        };
                    }
                    else if(type===Number){
                        return (el,val)=>{
                            el.value=val; 
                        };
                    }
                    else if(type===Date){
                        return (el,val)=>{
                            el.value=val; 
                        };
                    }
                    else if(type===Boolean){
                        return (el,val)=>{
                            el.checked=val; 
                        };
                    }
                },
                getRow(rowkeyobj){
                    let keys = Object.keys(rowkeyobj);
                    let foundRow;
                    this.state.data.forEach( (row,index)=>{
                        let match = true;
                        keys.forEach((key)=>{
                            if(row[key]!=rowkeyobj[key]){
                                match=false;
                                return;
                            }
                        });
                        if(match == true ){
                            foundRow=row;
                            return;
                        }
                    });
                    return foundRow;
                },
                getRowKey(row){
                    return this.state.pkcols.map(( pkid )=>{ return pkid+'_'+row[pkid] }).join('-');
                },
                parseColType(str,col){
                    let type=this.state.options[col].type;
                    if(type===Number){
                        return str.type===String  ? parseFloat(str) : str;
                    }
                    else if(type===String){
                        return str.type===String ? str : str + "";
                    }
                    else if(type===Date){
                        return str;
                    }
                    else if(type===Boolean){
                        return str=="true" || str == 1 ? true : false
                    }
                },
                parseRowKey(rowkey){
                    let rowkeyobj={};
                    rowkey.split("-").forEach((key)=>{
                        let keypair = key.split("_");
                        rowkeyobj[keypair[0]]=this.parseColType(keypair[1],keypair[0]);
                    });
                    return rowkeyobj;
                },
                setPage(e){
                    if(e.target.value<1){
                        this.state.pagination.page=1;
                        this.state.pagination.start = (this.state.pagination.show*0);
                        this.state.pagination.end = (this.state.pagination.show*1);
                        this.state.pagination.max = Math.ceil(this.state.data.length/this.state.pagination.show);
                    }
                    else{
                        this.state.pagination.page = parseInt(e.target.value);
                        this.state.pagination.start = (this.state.pagination.show*(this.state.pagination.page))-this.state.pagination.show;
                        this.state.pagination.end = (this.state.pagination.show*this.state.pagination.page)+1;
                        this.state.pagination.max = Math.ceil(this.state.data.length/this.state.pagination.show);
                    }
                    this.update();
                },
                setPageCount(e){
                    this.state.pagination.show = parseInt(e.target.value);
                    let mockevent = {target:{value:"1"}};
                    this.setPage(mockevent);
                },
                getSelected(){
                    return Object.keys(this.state.selected);
                },
                rowMenu(e){
                    if(this.state.tableOptions.delete){
                        if(e.target.getAttribute("style")==null){
                            e.target.setAttribute('style','min-width:100px');
                            this.state.mode="modify";
                        }
                        else{
                            let counters = document.getElementsByClassName("cell-counter");
                            for(var i=0;i<counters.length;i++){
                                counters[0].removeAttribute("style");
                            }
                            this.state.mode="";
                        }
                        this.update();
                    }
                },
                toggleAll(e){
                    if(this.state.all){
                        this.state.all=false;
                        this.state.selected={};
                        this.state.selectedcnt=0;
                    }
                    else{
                        for(var i=0;i<this.state.data.length;i++){
                            let rowpairkey = this.getRowKey(this.state.data[i]);
                            let rowkeyobj = this.parseRowKey(rowpairkey);
                            this.state.selected[rowpairkey]=rowkeyobj;
                        }
                        this.state.all=true;
                        this.state.selectedcnt=this.state.data.length;
                    }
                    this.update();
                },
                toggleRow(e){
                    let rowpairkey= e.target.getAttribute("data-selectkey");
                    let rowkeyobj=this.parseRowKey(rowpairkey);
                    if(rowpairkey in this.state.selected){
                        //remove item
                        this.state.all=false;
                        delete this.state.selected[rowpairkey];
                    }
                    else{
                        //add item (check if all selected)
                        this.state.selected[rowpairkey]=rowkeyobj;
                        if(Object.keys(this.state.selected).length==this.state.data.length){
                            this.state.all=true;
                        }
                    }
                    this.state.selectedcnt=Object.keys(this.state.selected).length;
                    
                    this.update();
                    this.setExternalInputs();
                },
                postMenu(e){
                    this.state.mode = this.state.mode=="post"?"":"post";
                    this.update();
                },
                isVisible(rowIndex){
                    return (
                        rowIndex+1 > this.state.pagination.start &&
                        rowIndex+1 < this.state.pagination.end
                    );
                },
                control(e){
                    if(e.key == "Tab" || e.key =="ArrowDown" || e.key == "Enter"){
                        e.preventDefault();
                    }
                    let datakeys=this.state.datakeys.filter((key)=>{
                        return this.state.options[key].visible
                    });
                    let rowpathindex=this.state.path.length-2;
                    let keypathindex=this.state.path.length-1;
                    let curkey= this.state.path[keypathindex];
                    let curkeyindex;
                    let rowindex= this.state.path[rowpathindex];
                    let curpath = JSON.parse(JSON.stringify(this.state.path));
                    datakeys.forEach((key,index)=>{
                        if(key==curkey){
                            curkeyindex=index;
                        }
                    })
                    if(curkeyindex===undefined || curkeyindex==null){
                        rowindex < this.state.data.length-1  ? curpath[rowpathindex]++ : 0
                        curkeyindex=0;
                    }
                    if(e.key == "Tab"){
                        this.applyPut(e,true);
                        if(this.state.shiftmodifier){
                            if(curkeyindex==0){
                                rowindex == 0  ? curpath[rowpathindex]=this.state.data.length-1 : curpath[rowpathindex]-- ;
                            }
                            else{
                                curkeyindex--
                            }
                        }
                        else{   
                            if(curkeyindex<datakeys.length-1){
                                curkeyindex++
                            }
                            else{
                                curkeyindex=0;
                                rowindex < this.state.data.length-1  ? curpath[rowpathindex]++ : 0
                            } 
                        }
                        curpath[keypathindex]=datakeys[curkeyindex];
                        this.editState(curpath);
                    }
                    if(e.key == "Enter" || e.key == "ArrowDown") {
                        this.applyPut(e,true);
                        rowindex < this.state.data.length-1  ? curpath[rowpathindex]++ : 0
                        this.editState(curpath)
                    }
                    if(e.key == "ArrowUp"){
                        this.applyPut(e,true);
                        rowindex == 0 ? curpath[rowpathindex] = this.state.data.length-1 : curpath[rowpathindex]--;
                        this.editState(curpath);
                    }
                    if(e.key == "Escape"){
                        this.editState([]);
                    }
                },
                controlModifier(e){
                    if(e.key=="Shift"){
                        if(e.type=="keydown"){
                            this.state.shiftmodifier=true;
                        }
                        else if(e.type=="keyup"){
                            this.state.shiftmodifier=false;
                        }
                    }
                },
                leavetable(path){
                    let oldvalue = JSON.stringify(path);
                    setTimeout(()=>{
                        oldvalue == this.state.pathstr ? this.editState([]) : false ;
                    },200)
                },
                editState(path){
                    this.state.prevPath=this.state.path;
                    let exists = this.state.pathstr != JSON.stringify(path) && JSON.stringify(path) !="[]";
                    this.state.path=path;
                    this.state.pathstr=JSON.stringify(path);
                    // ------------------ UnSelect all but viewed row
                    if(path.length>1){
                        this.state.all=false;
                        let selectionKey=this.getRowKey(this.state.data[path[0]]);
                        this.state.selected={}; 
                        this.state.selected[selectionKey]=this.parseRowKey(selectionKey);
                        this.state.selectedcnt=1;
                    }
                    // ------------------
                    this.update();
                    if(exists){
                        let id =  '#input-control-'+path[path.length-2]+'-'+path[path.length-1]+'-'+this.getPKID().join("-");
                        console.log(this.state.tableOptions);
                        if(path.length>0 && this.state.tableOptions.put==true){
                            let type = this.state.options[path[1]].type;
                            let setter = this.getInputSetMethod(type);
                            let input = this.$(id);
                            let value = this.state.data[path[0]][path[1]];
                            setter(input,value);
                            if(input){
                                input.focus();
                                input.select();
                            }
                        }
                        this.setExternalInputs();
                    }
                },
                setExternalInputs(){
                    this.state.datakeys.forEach((key)=>{
                        if(this.state.options[key].externalInput){
                            let firstRow;
                            let matching=true;
                            let selectedkeys=Object.keys(this.state.selected);
                            
                            if(selectedkeys.length>0){
                                selectedkeys.forEach((selectedkey,index)=>{
                                    if(index==0){
                                        firstRow=this.getRow(this.state.selected[selectedkey]);
                                    }
                                    else{
                                        let nextrow=this.getRow(this.state.selected[selectedkey]);
                                        if(nextrow[key]!=firstRow[key]){
                                            matching=false;
                                            return;
                                        }
                                    }
                                });
                                if(matching){
                                    this.setExternalInput(firstRow,key);
                                }
                            }
                            else{
                                if(this.state.path.length!=0){
                                    let path=this.state.path;
                                    this.setExternalInput(this.state.data[path[0]],key)
                                }
                            }
                        }
                    });
                },
                setExternalInput(row,key){
                    let externalInput = this.state.options[key].externalInput;
                    if(externalInput){
                        let type = this.state.options[key].type;
                        let setter = this.getInputSetMethod(type);
                        let input = document.querySelector(externalInput);
                        let value = row[key];
                        setter(input,value);
                    }
                },
                applyPutExternal(e){
                    let rowKey="";
                    this.state.datakeys.forEach((key)=>{
                        let externalInput = this.state.options[key].externalInput;
                        if(externalInput){
                            let match = e.path[1].querySelector(externalInput);
                            if(match == document.querySelector(externalInput)){
                                rowKey=key;
                            }
                        }
                    })
                    let selectedKeys = Object.keys(this.state.selected);
                    if( selectedKeys.length>0){
                        let oldRows=[];
                        let newRows=[];
                        let editRows=[];
                        let type = this.state.options[rowKey].type;
                        let getter = this.getInputGetMethod(type);
                        let setValue = getter(e);
    
                        selectedKeys.forEach((selectedkey)=>{
                            let editRow=this.getRow(this.state.selected[selectedkey]);
                            editRows.push(editRow);
                            let oldRow=JSON.parse(JSON.stringify(editRow));
                            oldRows.push(oldRow);
                            let newRow=JSON.parse(JSON.stringify(oldRow));
                            newRow[rowKey]=setValue;
                            newRows.push(newRow);
                        });
    
                        let confirmPut = (confirm)=>{
                            if(confirm){
                                editRows.forEach((row)=>{
                                    row[rowKey]=setValue;
                                });
                                this.update();
                            }                        
                        }
                        
                        this.state.callbacks.put({
                            pkcols: this.state.pkcols,
                            type: "put",
                            old: oldRows,
                            new: newRows,
                            confirm: ( this.debugMode ? confirmPut( true ) : confirmPut )
                        });
                    }
                    else{
                        this.state.prevPath = this.state.path;
                        let newPath;
                        if(JSON.stringify(this.state.path)=="[]"){
                            newPath = [0,rowKey];
                        }
                        else{
                            newPath = [this.state.path[0],rowKey];
                        }
                        this.state.path = newPath;
                        this.applyPut(e);
                        this.update();
                    }
                },
                applyPut(e,preventNextChange=false){
                    let path = this.state.path;
                    if(path.length>0 && this.state.preventNextChange==false){
                        let type = this.state.options[path[1]].type;
                        let getter = this.getInputGetMethod(type);
                        let old=JSON.parse(JSON.stringify(this.state.data[path[0]]));
                        let setValue=getter(e);
                        let newRow = JSON.parse(JSON.stringify(this.state.data[path[0]]));
                        newRow[path[1]]=setValue;
                        if(JSON.stringify(old)!=JSON.stringify(newRow)){
                            let confirmPut = (Confirm)=>{
                                if(Confirm){
                                    this.state.data[path[0]][path[1]] = setValue;
                                    this.update();
                                    return true;
                                }
                                return false;
                            }
                            this.state.callbacks.put({
                                pkcols: this.state.pkcols,
                                type: "put",
                                old: old,
                                new: newRow,
                                confirm: ( this.debugMode ? confirmPut( true ) : confirmPut )
                            });
                            
                        }
                        this.state.preventNextChange=preventNextChange;
                    }
                    else{
                        this.state.preventNextChange=false;
                    }
                },
                editPost(e){
                    //save postable content to object to send
                    let key = e.target.getAttribute("data-postkey");
                    let type = this.state.options[key].type;
                    let getter = this.getInputGetMethod(type);
                    this.state.new[key]=getter(e);
                },
                applyPost(e){
                    //send object to post callback
                    let postback = JSON.parse(JSON.stringify(this.state.new));
                    let postbackPKID = this.getPKID();
                    let postbackPKIDObj = {};
                    postbackPKID.forEach((pkid)=>{
                        postbackPKIDObj[pkid]=null;
                    });
    
                    let confirmPost = (PKIDMergeObj)=>{
                        if(PKIDMergeObj){
                            this.state.data.push(Object.assign(postback,PKIDMergeObj));
                            this.state.datakeys.forEach((key)=>{
                                let input = this.$('#new-insert-'+key);
                                input !== undefined ? input.value='':0;
    
                            })
                            this.state.new={};
                            this.update();
                            return true;
                        }
                        return false;
                    }
    
                    if(this.debugMode){
                        postbackPKID.forEach((pkcol)=>{
                            postbackPKIDObj[pkcol] = this.uuidv4();
                        });
                    } 
                    this.state.callbacks.post({
                        pkcols:postbackPKID,
                        type:"post",
                        new:postback,
                        confirmContent:postbackPKIDObj,
                        confirm: ( this.debugMode ? confirmPost( postbackPKIDObj ) : confirmPost )
                    });
                },
                applyDelete(e){
                    let selectkeys=Object.keys(this.state.selected).map((key)=>this.state.selected[key]);
    
                    e.preventDefault();
                    e.stopPropagation();
    
                    let confirmdelete = (result,callback=(deleted,selectkeys)=>{ console.log("client side delete failed",deleted,selectkeys) })=>{
                            if(result){
                                let deleted=[];
                                for(var i=0;i<this.state.data.length;i++){
                                    let match=false;
                                    selectkeys.forEach((selectkey)=>{
                                        let keymatch=true;
                                        Object.keys(selectkey).forEach((key)=>{
                                            if(this.state.data[i][key]!=selectkey[key]){
                                                keymatch=false;
                                            }
                                        })
                                        if(keymatch){
                                            match=true;
                                        }
                                    });
                                    if(match){
                                        deleted.push(this.state.data[i]);
                                        this.state.data.splice(i,1);
                                        i--;
                                    }
                                }
                                if(deleted.length!=selectkeys.length){
                                    callback(deleted,selectkeys);
                                }
                                this.update();
                                return true;
                            }
                            return false;
                        };
    
                    this.state.callbacks.delete({
                        old: selectkeys,
                        type:"delete",
                        confirm: (this.debugMode ? confirmdelete(true) : confirmdelete)  
                    })
                },
                uuidv4() {
                    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                        return v.toString(16);
                    })
                },  
                sort(key){
                    var numsorts = this.calcSortOrder();
                    let oldkey = key in this.state.sort && this.state.sort[key].type ? this.state.sort[key].type :"NONE";
                    if(!this.state.shiftmodifier){
                        this.state.sort={};
                        this.state.sort[key]={
                            type:oldkey,
                            order:0
                        }
                    }
                    if(this.state.sort[key]===undefined){
                        this.state.sort[key]={
                            type:"DESC",
                            order:numsorts.length-1
                        }
                    } 
                    else if(this.state.sort[key].type=="NONE"){
                        this.state.sort[key].type="DESC";
                    }
                    else if(this.state.sort[key].type=="DESC"){
                        this.state.sort[key].type="ASC";
                    }
                    else if(this.state.sort[key].type=="ASC"){
                        delete this.state.sort[key];
                    }
    
                    var finalsortorder=this.calcSortOrder();
                    this.buildSort(finalsortorder);
                    this.update();
                },
                calcSortOrder(){
                    var numsorts = Object.keys(this.state.sort);
                    for(var i=0;i<numsorts.length-1;i++){
                        if(this.state.sort[numsorts[i]].order > this.state.sort[numsorts[i+1]].order){
                            let forward = numsorts[i];
                            numsorts=numsorts.splice(i,1,numsorts[i+1]);
                            numsorts[i+1]=forward;
                        }
                    }
                    for(var i=0;i<numsorts.length;i++){
                        this.state.sort[numsorts[i]].order=i;
                    }
                    return numsorts;
                },
                buildSort(orderedsorts){
                    var thisref=this;
                    function dimensionalSort(dimensionalsorts, dimensionalindex=0,a,b){
                        if(dimensionalindex<dimensionalsorts.length){
                            let key=dimensionalsorts[dimensionalindex];
                            let sortresult=thisref.state.typeSort[thisref.state.options[key].type.name](a[key],b[key]);
                            sortresult = thisref.state.sort[key].type=="ASC" ? sortresult : -1 * sortresult;
                            dimensionalindex++;
                            return sortresult==0 ? dimensionalSort(dimensionalsorts,dimensionalindex,a,b) : sortresult;
                        }
                        return 0;
                    }
                    this.state.data = this.state.data.sort((a,b)=>{ 
                        return dimensionalSort(orderedsorts,0,a,b);
                    });
                },
                visibleCols(){
                    let visibleCount = 0;
                    Object.keys(this.state.options).forEach((key)=>{
                        this.state.options[key].visible ? visibleCount++ : 0 ;
                    })
                    return visibleCount-1;
                }
            }
        </script>
    </widget-grid>