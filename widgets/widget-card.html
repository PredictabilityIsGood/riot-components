<widget-card>
    <div class="card-deck m-4">
        <div each="{row in state.data}" class="card mt-2" style="min-width:250px;">
            <img src="{row[state.imagekeys[0]]}" class="card-img-top" alt="...">
            <div class="card-body">
                <div class="row"
                    if="{state.options[key].type!==Image && (state.options[key].visible==true || state.options[key].externalInput != false)}"
                    each="{key in state.datakeys}">
                    <div class="col-sm-12 col-md-4">
                        <h6 class="card-title text-muted p-0">
                            <small>{state.options[key].alias ? state.options[key].alias : key }</small>
                        </h6>
                    </div>
                    <div class="col-sm-12 col-md-8">
                        <p class="card-text">
                            {row[key]}
                        </p>
                    </div>
                </div>

                <button class="invisible btn btn-primary bg-booking m-2" type="button">
                    More Info
                </button>
                <div class="position-absolute text-center m-4" style="bottom:0;left:0;">
                    <button class="btn btn-primary bg-booking" type="button">
                        More Info
                    </button>
                </div>
            </div>
        </div>
    </div>
    <script>
        export default {
            state: {
                data:[],
                new:{},
                external:{},
                selected:{},
                selectedcnt:0,
                path:[],
                pathstr:"",
                datakeys:[],
                shiftmodifier:false,
                tabbed:false,
                pagination:{},
                callbacks:{},
                options:{},
                tableOptions:{},
                sort:{},
                theme:{},
                firstRun:true,
                mode:"",
                all:false,
                imagekeys:[]
            },
            debugMode:false,
            debug:{
                data:[
                        {
                            "Id":1,
                            "Name":"Ryan",
                            "Age":27,
                            "Email":"test@test.com",
                            "Is":false,
                            "StartDate":"2018-01-01T00:00:01",
                            "State":"NY",
                            "City":"Glen Cove",
                            "Address":"100 Test Street",
                            "Sex":"M"
                        },{
                            "Id":2,
                            "Name":"Kiichi",
                            "Age":null,
                            "Email":"anothertest@test.com",
                            "Is":true,
                            "StartDate":"2002-01-01T00:00:01",
                            "State":"NY",
                            "City":"Test City",
                            "Address":"200 Test Street",
                            "Sex":"M"
                        },{
                            "Id":3,
                            "Name":"Justin",
                            "Age":null,
                            "Email":"testing123@test.com",
                            "Is":false,
                            "StartDate":"2018-01-01T00:00:01",
                            "State":"NY",
                            "City":"Another Test City",
                            "Address":"100 Test Street",
                            "Sex":"M"
                        },{
                            "Id":4,
                            "Name":"Korey",
                            "Age":null,
                            "Email":"information@test.com",
                            "Is":false,
                            "StartDate":null,
                            "State":"NY",
                            "City":"Another Test City",
                            "Address":"150 Test Street",
                            "Sex":"M"
                        },{
                            "Id":5,
                            "Name":"James",
                            "Age":null,
                            "Email":"testinformation@test.com",
                            "Is":false,
                            "StartDate":null,
                            "State":"NJ",
                            "City":"Cityopolis",
                            "Address":"100 Test Street",
                            "Sex":"M"
                        }
                    ],
                callbacks:{},
                options:{
                    "Id":{
                        alias:"UserID",
                        pk:true,
                        put:false,
                        visible:false
                    },
                    "Name":{
                        alias:"Involved Person"
                    },
                    "Age":{
                        alias:"Incident Age",
                        type:Number,
                    },
                    "Is":{
                    },
                    "StartDate":{
                        externalInput:"#start-date",
                        visible:false
                    },
                    "State":{
                        externalInput:"#state-input",
                        visible:false
                    },
                    "City":{
                        externalInput:"#city-input",
                        visible:false
                    },
                    "Address":{
                        externalInput:"#address-input",
                        visible:false
                    },
                    "Sex":{
                        externalInput:"#sex-input",
                        visible:false
                    }
                },
                tableOptions:{
                    put:true,
                    post:true,
                    delete:true
                },
                typeSort:{
                    "String":(a,b)=>{
                        return a.localeCompare(b);
                    },
                    "Number":(a,b)=>{
                        a=a==null?-Infinity:a;
                        b=b==null?-Infinity:b;
                        let result = parseFloat(a)-parseFloat(b);
                        if(isNaN(result)){
                            return 0;
                        }
                        else{
                            result=result==-Infinity?-1:result;
                            result=result==Infinity?1:result;
                            return result;
                        }
                    },
                    "Date":(a,b)=>{
                        return a-b;
                    },
                    "Boolean":(a,b)=>{
                        return a-b;
                    }
                },
                theme:{
                    bg:"light",
                    border:"light",
                    text:"dark",
                    matchContents:true
                }
            },
            defaults:{
                data:[],
                callbacks:{
                    put:(updated)=> console.log(updated),
                    post:(created)=> console.log(created),
                    delete:(deleted)=> console.log(deleted),
                    success:(success)=> console.log(success),
                    failed:(failed)=> console.log(failed)
                },
                options:{
                    alias:null,
                    type:String,
                    autotype:(value)=>{return value.constructor},
                    visible:true,
                    put:true,
                    pk:false,
                    externalInput:false,
                    externalChange:false,
                    sort:null
                },
                tableOptions:{
                    put:true,
                    delete:true,
                    post:true,
                    pagination:true,
                    footer:true,
                    externalPost:false
                },
                typeSort:{
                    "String":(a,b)=>{
                        return a.localeCompare(b);
                    },
                    "Number":(a,b)=>{
                        a=a==null?-Infinity:a;
                        b=b==null?-Infinity:b;
                        let result = parseFloat(a)-parseFloat(b);
                        if(isNaN(result)){
                            return 0;
                        }
                        else{
                            result=result==-Infinity?-1:result;
                            result=result==Infinity?1:result;
                            return result;
                        }
                    },
                    "Date":(a,b)=>{
                        return a-b;
                    },
                    "Boolean":(a,b)=>{
                        return a-b;
                    }
                },
                theme:{
                    bg:"light",
                    border:"light",
                    text:"dark",
                    matchContents:true
                }
            },
            windowkeyup:null,
            windowkeydown:null,
            onBeforeMount(props, state) {
                this.bind(props, state);
            },
            onBeforeUpdate(props, state) {
            },
            onBeforeUnmount() {
                this.unbind();
            },
            bind(props, state) {
                this.state.pagination = {
                    show: 10,
                    page: 1,
                    start: 0,
                    end: 10,
                    max: 1,
                };
                
                this.state.selected = {};
                this.state.selectedcnt = 0;
                this.state.sort = {};
                this.state.options = {};
                this.state.tableOptions = {};
                this.state.theme = {};

                if (props.debugMode == true) {
                    this.debugMode = props.debugMode;
                    console.log(this, " - debug mode on (widget-card)");
                    if (props.debug) {
                        this.debug = props.debug;
                    }
                }

                let configuration = this.debugMode ? this.debug : props;
                this.windowkeyup = (e) => this.controlModifier(e);
                window.addEventListener("keyup", this.windowkeyup);
                this.windowkeydown = (e) => this.controlModifier(e);
                window.addEventListener("keydown", this.windowkeydown);


                // set underlying table data
                this.state.data = configuration.data || this.debug.data;

                // set initial data keys                
                this.state.datakeys = this.state.data.length > 0 ? Object.keys(this.state.data[0]) : Object.keys(configuration.options);

                // set table operation callbacks - functions cannot use assign
                let callbacks = Object.assign({}, this.defaults.callbacks);
                Object.keys(callbacks).forEach((callback) => {
                    callbacks[callback] = configuration.callbacks && configuration.callbacks[callback] ? configuration.callbacks[callback] : callbacks[callback];
                });
                this.state.callbacks = callbacks;
                // set column options (autotype, typeoverride, visible, insert, update, delete, pk)
                /* setting column options requires iterating through data's key, determinine generic autotype and overriding with users entered overrides via props */

                this.state.datakeys.forEach((key) => {
                    let columnOptions = Object.assign({}, this.defaults.options);

                    Object.keys(columnOptions).forEach((optionname) => {
                        columnOptions[optionname] = configuration.options[key] && optionname in configuration.options[key] ? configuration.options[key][optionname] : columnOptions[optionname];
                    });

                    if (!(key in configuration.options) || !configuration.options[key].type) {
                        let i = 0; //search until first auto-type is found for col not null
                        let autotype = null;
                        while (autotype == null && i < this.state.data.length) {
                            if (this.state.data[i][key] != null) {
                                columnOptions.autotype = columnOptions.autotype(this.state.data[i][key]);
                                autotype = true;
                            }
                            i++;
                        }
                        columnOptions.type = columnOptions.autotype;
                    }
                    this.state.options[key] = columnOptions; // set column options
                    
                    if(this.state.options[key].type===Image){
                        this.state.imagekeys.push(key);
                    }
                });

                // set table options (post,delete)
                this.state.tableOptions = Object.assign({}, this.defaults.tableOptions);
                this.state.tableOptions = configuration.tableOptions ? Object.assign(this.state.tableOptions, configuration.tableOptions) : this.state.tableOptions;
                let externalPostBtn = document.querySelector(this.state.tableOptions.externalPost)
                externalPostBtn ? externalPostBtn.addEventListener("click", this.applyPost) : 0;

                // set typeSort options
                this.state.typeSort = Object.assign({}, this.defaults.typeSort);
                this.state.typeSort = configuration.typeSort ? Object.assign(this.state.typeSort, configuration.typeSort) : this.state.typeSort;

                //set theme options
                this.state.theme = Object.assign({}, this.defaults.theme);
                this.state.theme = configuration.theme ? Object.assign(this.state.theme, configuration.theme) : this.state.theme;

                //set pkcols
                this.state.pkcols = this.getPKID();
                this.state.pkidstr = this.state.pkcols.join("::-::");

                if (configuration.path && this.state.firstRun) {
                    this.state.path = configuration.path;
                    this.state.pathstr = JSON.stringify(configuration.path);
                    let path = this.state.path;
                    this.state.firstRun = false;
                }
            },
            unbind() {
                this.state.imagekeys=[];
                this.state.datakeys.forEach((key) => {
                    let externalInput = this.state.options[key].externalInput;
                    if (externalInput) {
                        let el = document.querySelector(externalInput);
                        if(el){
                            el.removeEventListener("change", this.applyPutExternal);
                            let type = this.state.options[key].type;
                            let setter = this.getInputSetMethod(type);
                            setter(el, this.state.external[key]);
                        }
                    }
                });

                let externalPostBtn = document.querySelector(this.state.tableOptions.externalPost)
                externalPostBtn ? externalPostBtn.removeEventListener("click", this.applyPost) : 0;

                if (this.windowkeyup) {
                    window.removeEventListener("keyup", this.windowkeyup);
                    window.removeEventListener("keydown", this.windowkeydown);
                }
                else {
                    console.log(this.windowkeyup, "keyevents wiped prior to app mount");
                }
            },
            getPKID() {
                let PKID = [];
                this.state.datakeys.forEach((key) => {
                    this.state.options[key].pk ? PKID.push(key) : 0;
                })
                return PKID;
            },
            getInputType(type) {
                if (type === String) {
                    return 'textbox';
                }
                else if (type === Number) {
                    return 'number';
                }
                else if (type === Date) {
                    return 'datetime';
                }
                else if (type === Boolean) {
                    return 'checkbox';
                }
                else if (type === Image) {
                    return 'file'
                }
            },
            getInputGetMethod(type) {
                if (type === String) {
                    return (e) => {
                        return e.target.value;
                    };
                }
                else if (type === Number) {
                    return (e) => {
                        return e.target.value;
                    };
                }
                else if (type === Date) {
                    return (e) => {
                        return e.target.value;
                    };
                }
                else if (type === Boolean) {
                    return (e) => {
                        return e.target.checked;
                    };
                }
            },
            getInputSetMethod(type) {
                if (type === String) {
                    return (el, val) => {
                        el.value = val;
                    };
                }
                else if (type === Number) {
                    return (el, val) => {
                        el.value = val;
                    };
                }
                else if (type === Date) {
                    return (el, val) => {
                        el.value = val;
                    };
                }
                else if (type === Boolean) {
                    return (el, val) => {
                        el.checked = val;
                    };
                }
            },
            getRow(rowkeyobj) {
                let keys = Object.keys(rowkeyobj);
                let foundRow;
                this.state.data.forEach((row, index) => {
                    let match = true;
                    keys.forEach((key) => {
                        if (row[key] != rowkeyobj[key]) {
                            match = false;
                            return;
                        }
                    });
                    if (match == true) {
                        foundRow = row;
                        return;
                    }
                });
                return foundRow;
            },
            getRowKey(row) {
                return this.state.pkcols.map((pkid) => { return pkid + "::_::" + row[pkid] }).join("::-::");
            },
            parseColType(str, col) {
                let type = this.state.options[col].type;
                if (type === Number) {
                    return str.type === String ? parseFloat(str) : str;
                }
                else if (type === String) {
                    return str.type === String ? str : str + "";
                }
                else if (type === Date) {
                    return str;
                }
                else if (type === Boolean) {
                    return str == "true" || str == 1 ? true : false
                }
            },
            parseRowKey(rowkey) {
                let rowkeyobj = {};
                rowkey.split("::-::").forEach((key) => {
                    let keypair = key.split("::_::");
                    rowkeyobj[keypair[0]] = this.parseColType(keypair[1], keypair[0]);
                });
                return rowkeyobj;
            },
            setPage(e) {
                if (e.target.value < 1) {
                    this.state.pagination.page = 1;
                    this.state.pagination.start = (this.state.pagination.show * 0);
                    this.state.pagination.end = (this.state.pagination.show * 1);
                    this.state.pagination.max = Math.ceil(this.state.data.length / this.state.pagination.show);
                }
                else {
                    this.state.pagination.page = parseInt(e.target.value);
                    this.state.pagination.start = (this.state.pagination.show * (this.state.pagination.page)) - this.state.pagination.show;
                    this.state.pagination.end = (this.state.pagination.show * this.state.pagination.page) + 1;
                    this.state.pagination.max = Math.ceil(this.state.data.length / this.state.pagination.show);
                }
                this.update();
            },
            setPageCount(e) {
                this.state.pagination.show = parseInt(e.target.value);
                let mockevent = { target: { value: "1" } };
                this.setPage(mockevent);
            },
            getSelected() {
                return Object.keys(this.state.selected);
            },
            rowMenu(e) {
                if (this.state.tableOptions.delete) {
                    if (e.target.getAttribute("style") == null) {
                        e.target.setAttribute('style', 'min-width:100px');
                        this.state.mode = "modify";
                    }
                    else {
                        let counters = document.getElementsByClassName("cell-counter");
                        for (var i = 0; i < counters.length; i++) {
                            counters[0].removeAttribute("style");
                        }
                        this.state.mode = "";
                    }
                    this.update();
                }
            },
            toggleAll(e) {
                if (this.state.all) {
                    this.state.all = false;
                    this.state.selected = {};
                    this.state.selectedcnt = 0;
                }
                else {
                    for (var i = 0; i < this.state.data.length; i++) {
                        let rowpairkey = this.getRowKey(this.state.data[i]);
                        let rowkeyobj = this.parseRowKey(rowpairkey);
                        this.state.selected[rowpairkey] = rowkeyobj;
                    }
                    this.state.all = true;
                    this.state.selectedcnt = this.state.data.length;
                }
                this.update();
            },
            toggleRow(e) {
                let rowpairkey = e.target.getAttribute("data-selectkey");
                let rowkeyobj = this.parseRowKey(rowpairkey);
                if (rowpairkey in this.state.selected) {
                    //remove item
                    this.state.all = false;
                    delete this.state.selected[rowpairkey];
                }
                else {
                    //add item (check if all selected)
                    this.state.selected[rowpairkey] = rowkeyobj;
                    if (Object.keys(this.state.selected).length == this.state.data.length) {
                        this.state.all = true;
                    }
                }
                this.state.selectedcnt = Object.keys(this.state.selected).length;

                this.update();
                this.setExternalInputs();
            },
            postMenu(e) {
                this.state.mode = this.state.mode == "post" ? "" : "post";
                this.update();
            },
            isVisible(rowIndex) {
                return (
                    rowIndex + 1 > this.state.pagination.start &&
                    rowIndex + 1 < this.state.pagination.end
                );
            },
            control(e) {
                if (e.key == "Tab" || e.key == "ArrowDown" || e.key == "Enter") {
                    e.preventDefault();
                }
                let datakeys = this.state.datakeys.filter((key) => {
                    return this.state.options[key].visible
                });
                let rowpathindex = this.state.path.length - 2;
                let keypathindex = this.state.path.length - 1;
                let curkey = this.state.path[keypathindex];
                let curkeyindex;
                let rowindex = this.state.path[rowpathindex];
                let curpath = JSON.parse(JSON.stringify(this.state.path));
                datakeys.forEach((key, index) => {
                    if (key == curkey) {
                        curkeyindex = index;
                    }
                })
                if (curkeyindex === undefined || curkeyindex == null) {
                    rowindex < this.state.data.length - 1 ? curpath[rowpathindex]++ : 0
                    curkeyindex = 0;
                }
                if (e.key == "Tab") {
                    this.applyPut(e, true);
                    if (this.state.shiftmodifier) {
                        if (curkeyindex == 0) {
                            rowindex == 0 ? curpath[rowpathindex] = this.state.data.length - 1 : curpath[rowpathindex]--;
                        }
                        else {
                            curkeyindex--
                        }
                    }
                    else {
                        if (curkeyindex < datakeys.length - 1) {
                            curkeyindex++
                        }
                        else {
                            curkeyindex = 0;
                            rowindex < this.state.data.length - 1 ? curpath[rowpathindex]++ : 0
                        }
                    }
                    curpath[keypathindex] = datakeys[curkeyindex];
                    this.editState(curpath);
                }
                if (e.key == "Enter" || e.key == "ArrowDown") {
                    this.applyPut(e, true);
                    rowindex < this.state.data.length - 1 ? curpath[rowpathindex]++ : 0
                    this.editState(curpath)
                }
                if (e.key == "ArrowUp") {
                    this.applyPut(e, true);
                    rowindex == 0 ? curpath[rowpathindex] = this.state.data.length - 1 : curpath[rowpathindex]--;
                    this.editState(curpath);
                }
                if (e.key == "Escape") {
                    this.editState([]);
                }
            },
            controlModifier(e) {
                if (e.key == "Shift") {
                    if (e.type == "keydown") {
                        this.state.shiftmodifier = true;
                    }
                    else if (e.type == "keyup") {
                        this.state.shiftmodifier = false;
                    }
                }
            },
            leavetable(path) {
                let oldvalue = JSON.stringify(path);
                setTimeout(() => {
                    oldvalue == this.state.pathstr ? this.editState([]) : false;
                }, 200)
            },
            editState(path) {
                this.state.prevPath = this.state.path;
                let exists = this.state.pathstr != JSON.stringify(path) && JSON.stringify(path) != "[]";
                this.state.path = path;
                this.state.pathstr = JSON.stringify(path);
                // ------------------ UnSelect all but viewed row
                if (path.length > 1) {
                    this.state.all = false;
                    let selectionKey = this.getRowKey(this.state.data[path[0]]);
                    this.state.selected = {};
                    this.state.selected[selectionKey] = this.parseRowKey(selectionKey);
                    this.state.selectedcnt = 1;
                }
                // ------------------
                this.update();
                if (exists) {
                    let id = '#input-control-' + path[path.length - 2] + '-' + path[path.length - 1] + '-' + this.getPKID().join("::-::");
                    if (path.length > 0 && this.state.tableOptions.put == true) {
                        let type = this.state.options[path[1]].type;
                        let setter = this.getInputSetMethod(type);
                        let input = this.$(id);
                        let value = this.state.data[path[0]][path[1]];
                        setter(input, value);
                        if (input) {
                            input.focus();
                            input.select();
                        }
                    }
                    this.setExternalInputs();
                }
            },
            setExternalInputs() {
                this.state.datakeys.forEach((key) => {
                    if (this.state.options[key].externalInput) {
                        let firstRow;
                        let matching = true;
                        let selectedkeys = Object.keys(this.state.selected);
                        if (selectedkeys.length > 0) {
                            selectedkeys.forEach((selectedkey, index) => {
                                if (index == 0) {
                                    firstRow = this.getRow(this.state.selected[selectedkey]);
                                }
                                else {
                                    let nextrow = this.getRow(this.state.selected[selectedkey]);
                                    if (nextrow[key] != firstRow[key]) {
                                        matching = false;
                                        return;
                                    }
                                }
                            });
                            if (matching) {
                                this.setExternalInput(firstRow, key);
                            }
                        }
                        else {
                            if (this.state.path.length != 0) {
                                let path = this.state.path;
                                this.setExternalInput(this.state.data[path[0]], key)
                            }
                        }
                    }
                });
            },
            setExternalInput(row, key) {
                let externalInput = this.state.options[key].externalInput;
                if (externalInput) {
                    let type = this.state.options[key].type;
                    let setter = this.getInputSetMethod(type);
                    let input = document.querySelector(externalInput);
                    let value = row[key];
                    setter(input, value);
                    this.state.options[key].externalChange == true ? input.dispatchEvent(new Event("change")) : 0;
                }
            },
            applyPutExternal(e, key = null) {
                let rowKey = key;/*
                this.state.datakeys.forEach((key)=>{
                    let externalInput = this.state.options[key].externalInput;
                    if(externalInput){
                        let match = e.composedPath ?  e.composedPath()[1].querySelector(externalInput)  : e.path[1].querySelector(externalInput) ;
                        if(match == document.querySelector(externalInput)){
                            rowKey=key;
                        }
                    }
                })*/
                let selectedKeys = Object.keys(this.state.selected);
                if (selectedKeys.length > 0) {
                    let oldRows = [];
                    let newRows = [];
                    let editRows = [];
                    let type = this.state.options[rowKey].type;
                    let getter = this.getInputGetMethod(type);
                    let setValue = getter(e);

                    selectedKeys.forEach((selectedkey) => {
                        let editRow = this.getRow(this.state.selected[selectedkey]);
                        editRows.push(editRow);
                        let oldRow = JSON.parse(JSON.stringify(editRow));
                        oldRows.push(oldRow);
                        let newRow = JSON.parse(JSON.stringify(oldRow));
                        newRow[rowKey] = setValue;
                        newRows.push(newRow);
                    });
                    let confirmPut = (confirm) => {
                        if (confirm) {
                            editRows.forEach((row) => {
                                row[rowKey] = setValue;
                            });
                            this.update();
                        }
                    }
                    this.state.callbacks.put({
                        pkcols: this.state.pkcols,
                        type: "put",
                        old: oldRows,
                        new: newRows,
                        confirm: (this.debugMode ? confirmPut(true) : confirmPut)
                    });
                }
                else {
                    this.editPostExternal(e, key);
                }
            },
            applyPut(e) {
                let path = this.state.path;
                if (path.length > 0) {
                    let type = this.state.options[path[1]].type;
                    let getter = this.getInputGetMethod(type);
                    let old = JSON.parse(JSON.stringify(this.state.data[path[0]]));
                    let setValue = getter(e);
                    let newRow = JSON.parse(JSON.stringify(this.state.data[path[0]]));
                    let rowKey = this.getRowKey(old);
                    newRow[path[1]] = setValue;
                    if (JSON.stringify(old) != JSON.stringify(newRow)) {
                        let confirmPut = (Confirm) => {
                            if (Confirm) {
                                this.state.operations.put[rowKey] = {
                                    status: "complete"
                                };
                                this.state.data[path[0]][path[1]] = setValue;
                                this.update();
                                return true;
                            }
                            return false;
                        }

                        this.state.operations.put[rowKey] = {
                            status: "processing",
                        };
                        this.update();

                        this.state.callbacks.put({
                            pkcols: this.state.pkcols,
                            type: "put",
                            old: old,
                            new: newRow,
                            confirm: (this.debugMode ? setTimeout(() => { confirmPut(true) }, 2000) : confirmPut)
                        });

                    }
                }
            },
            editPostExternal(e, key) {
                //save postable content to object to send
                let type = this.state.options[key].type;
                let getter = this.getInputGetMethod(type);
                this.state.new[key] = getter(e);
            },
            editPost(e) {
                //save postable content to object to send
                let key = e.target.getAttribute("data-postkey");
                let type = this.state.options[key].type;
                let getter = this.getInputGetMethod(type);
                this.state.new[key] = getter(e);
            },
            applyPost(e) {
                //send object to post callback
                let postback = JSON.parse(JSON.stringify(this.state.new));
                let postbackPKID = this.getPKID();
                let postbackPKIDObj = {};
                postbackPKID.forEach((pkid) => {
                    postbackPKIDObj[pkid] = null;
                });

                let confirmPost = (PKIDMergeObj) => {
                    if (PKIDMergeObj) {
                        this.state.data.push(Object.assign(postback, PKIDMergeObj));
                        this.state.datakeys.forEach((key) => {
                            let input = this.$('#new-insert-' + key);
                            input !== undefined ? input.value = '' : 0;

                        })
                        this.state.new = {};
                        this.update();
                        return true;
                    }
                    return false;
                }

                if (this.debugMode) {
                    postbackPKID.forEach((pkcol) => {
                        postbackPKIDObj[pkcol] = this.uuidv4();
                    });
                }

                let keysToReset = Object.keys(this.state.external);
                keysToReset.forEach((key) => {
                    let externalInput = this.state.options[key].externalInput;
                    if (externalInput) {
                        let el = document.querySelector(externalInput);
                        el ? el.removeEventListener("change", this.applyPutExternal) : 0;
                        let type = this.state.options[key].type;
                        let setter = this.getInputSetMethod(type);
                        setter(el, this.state.external[key]);
                    }
                });

                this.state.callbacks.post({
                    pkcols: postbackPKID,
                    type: "post",
                    new: postback,
                    confirmContent: postbackPKIDObj,
                    confirm: (this.debugMode ? setTimeout(() => { confirmPost(postbackPKIDObj) }, 2000) : confirmPost)
                });
            },
            applyDelete(e) {
                let selectkeys = Object.keys(this.state.selected).map((key) => this.state.selected[key]);

                e.preventDefault();
                e.stopPropagation();

                let confirmdelete = (result, callback = (deleted, selectkeys) => { console.log("client side delete failed", deleted, selectkeys) }) => {
                    if (result) {
                        let deleted = [];
                        for (var i = 0; i < this.state.data.length; i++) {
                            let match = false;
                            selectkeys.forEach((selectkey) => {
                                let keymatch = true;
                                Object.keys(selectkey).forEach((key) => {
                                    if (this.state.data[i][key] != selectkey[key]) {
                                        keymatch = false;
                                    }
                                })
                                if (keymatch) {
                                    match = true;
                                }
                            });
                            if (match) {
                                deleted.push(this.state.data[i]);
                                this.state.data.splice(i, 1);
                                i--;
                            }
                        }
                        if (deleted.length != selectkeys.length) {
                            callback(deleted, selectkeys);
                        }
                        this.update();
                        return true;
                    }
                    return false;
                };

                this.state.callbacks.delete({
                    old: selectkeys,
                    type: "delete",
                    confirm: (this.debugMode ? confirmdelete(true) : confirmdelete)
                })
            },
            uuidv4() {
                return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                })
            },
            sort(key) {
                var numsorts = this.calcSortOrder();
                let oldkey = key in this.state.sort && this.state.sort[key].type ? this.state.sort[key].type : "NONE";
                if (!this.state.shiftmodifier) {
                    this.state.sort = {};
                    this.state.sort[key] = {
                        type: oldkey,
                        order: 0
                    }
                }
                if (this.state.sort[key] === undefined) {
                    this.state.sort[key] = {
                        type: "DESC",
                        order: numsorts.length - 1
                    }
                }
                else if (this.state.sort[key].type == "NONE") {
                    this.state.sort[key].type = "DESC";
                }
                else if (this.state.sort[key].type == "DESC") {
                    this.state.sort[key].type = "ASC";
                }
                else if (this.state.sort[key].type == "ASC") {
                    delete this.state.sort[key];
                }

                var finalsortorder = this.calcSortOrder();
                this.buildSort(finalsortorder);
                this.update();
            },
            calcSortOrder() {
                var numsorts = Object.keys(this.state.sort);
                for (var i = 0; i < numsorts.length - 1; i++) {
                    if (this.state.sort[numsorts[i]].order > this.state.sort[numsorts[i + 1]].order) {
                        let forward = numsorts[i];
                        numsorts = numsorts.splice(i, 1, numsorts[i + 1]);
                        numsorts[i + 1] = forward;
                    }
                }
                for (var i = 0; i < numsorts.length; i++) {
                    this.state.sort[numsorts[i]].order = i;
                }
                return numsorts;
            },
            buildSort(orderedsorts) {
                var thisref = this;
                function dimensionalSort(dimensionalsorts, dimensionalindex = 0, a, b) {
                    if (dimensionalindex < dimensionalsorts.length) {
                        let key = dimensionalsorts[dimensionalindex];
                        let sortresult = thisref.state.typeSort[thisref.state.options[key].type.name](a[key], b[key]);
                        sortresult = thisref.state.sort[key].type == "ASC" ? sortresult : -1 * sortresult;
                        dimensionalindex++;
                        return sortresult == 0 ? dimensionalSort(dimensionalsorts, dimensionalindex, a, b) : sortresult;
                    }
                    return 0;
                }
                this.state.data = this.state.data.sort((a, b) => {
                    return dimensionalSort(orderedsorts, 0, a, b);
                });
            },
            visibleCols() {
                let visibleCount = 0;
                Object.keys(this.state.options).forEach((key) => {
                    this.state.options[key].visible ? visibleCount++ : 0;
                })
                return visibleCount - 1;
            }
        }
    </script>
</widget-card>